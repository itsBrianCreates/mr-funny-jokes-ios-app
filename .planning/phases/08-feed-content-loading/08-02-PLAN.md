---
phase: 08-feed-content-loading
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift
  - MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift
autonomous: false

must_haves:
  truths:
    - "Feed shows only unrated jokes, sorted by popularity score (highest first)"
    - "When user rates a joke, it stays visible until next refresh"
    - "Background catalog loading starts when user first scrolls, not on app launch"
    - "Pull-to-refresh resets feed to page 1 and clears session-rated tracking"
    - "Rated jokes are accessible in the Me tab (already implemented)"
  artifacts:
    - path: "MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift"
      provides: "Background catalog loading, unrated-only filtering, session tracking"
      contains: "isBackgroundLoadingComplete"
    - path: "MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift"
      provides: "Pull-to-refresh with full reset, error retry button"
      contains: ".refreshable"
  key_links:
    - from: "JokeViewModel filteredJokes"
      to: "storage.getRatedJokeIdsFast()"
      via: "filter excluding rated jokes"
      pattern: "userRating.*nil"
    - from: "JokeFeedView.refreshable"
      to: "JokeViewModel.refresh()"
      via: "async call"
      pattern: "refreshable.*viewModel\\.refresh"
---

<objective>
Implement background catalog loading and unrated-only feed filtering with popularity sorting.

Purpose: Users see fresh, unrated jokes first (sorted by trending/popularity). Rated jokes move to the Me tab. Full catalog loads silently in background enabling proper sorting.

Output: JokeViewModel with background loading orchestration and unrated-only filtering; JokeFeedView with pull-to-refresh support.
</objective>

<execution_context>
@/Users/brianvanaski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brianvanaski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-feed-content-loading/08-CONTEXT.md
@.planning/phases/08-feed-content-loading/08-RESEARCH.md
@.planning/phases/08-feed-content-loading/08-01-SUMMARY.md
@MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift
@MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add background catalog loading to JokeViewModel</name>
  <files>MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift</files>
  <action>
Add background catalog loading infrastructure to JokeViewModel:

1. Add new state properties (after `hasMoreJokes`):
   ```swift
   /// Tracks if background catalog loading is complete
   @Published private(set) var isBackgroundLoadingComplete = false

   /// Background loading task reference for cancellation
   private var backgroundLoadTask: Task<Void, Never>?

   /// Tracks if background load has been triggered (only once per session)
   private var hasTriggeredBackgroundLoad = false

   /// Tracks jokes rated during this session (kept visible until refresh)
   private var sessionRatedJokeIds: Set<String> = []

   /// Batch size for background loading (larger than scroll loading for efficiency)
   private let backgroundBatchSize = 50
   ```

2. Add method to trigger background loading (called from loadMoreIfNeeded):
   ```swift
   /// Triggers background catalog loading if not already started
   /// Called on first scroll, not app launch (per CONTEXT.md)
   func triggerBackgroundLoadIfNeeded() {
       guard !hasTriggeredBackgroundLoad && !isBackgroundLoadingComplete else { return }
       hasTriggeredBackgroundLoad = true

       backgroundLoadTask = Task { [weak self] in
           await self?.loadFullCatalogInBackground()
       }
   }
   ```

3. Add the background loading method:
   ```swift
   /// Loads the full joke catalog silently in background
   /// Designed for 500-2000 jokes per CONTEXT.md
   private func loadFullCatalogInBackground() async {
       // Load in batches to avoid memory spikes
       while hasMoreJokes && !Task.isCancelled {
           do {
               let newJokes: [Joke]
               if let category = selectedCategory {
                   newJokes = try await firestoreService.fetchMoreJokes(category: category, limit: backgroundBatchSize)
               } else {
                   newJokes = try await firestoreService.fetchMoreJokes(limit: backgroundBatchSize)
               }

               guard !Task.isCancelled else { return }

               if newJokes.isEmpty {
                   break
               }

               // Apply user ratings
               let jokesWithRatings = newJokes.map { joke -> Joke in
                   var mutableJoke = joke
                   mutableJoke.userRating = storage.getRating(for: joke.id, firestoreId: joke.firestoreId)
                   return mutableJoke
               }

               // Merge with existing jokes, avoiding duplicates
               var updatedJokes = jokes
               for joke in jokesWithRatings {
                   if !updatedJokes.contains(where: { $0.setup == joke.setup && $0.punchline == joke.punchline }) {
                       updatedJokes.append(joke)
                   }
               }
               jokes = updatedJokes

               // Small delay between batches to avoid overwhelming
               try? await Task.sleep(for: .milliseconds(100))
           } catch {
               // Silent failure per CONTEXT.md - just stop loading
               break
           }
       }

       isBackgroundLoadingComplete = true
   }
   ```

4. Modify `loadMoreIfNeeded(currentItem:)` to trigger background loading:
   At the START of the method, add:
   ```swift
   // Trigger background catalog loading on first scroll
   triggerBackgroundLoadIfNeeded()
   ```

5. Modify the `refresh()` method to reset background loading state:
   At the START of the method (after the guard), add:
   ```swift
   // Cancel background loading and reset state
   backgroundLoadTask?.cancel()
   hasTriggeredBackgroundLoad = false
   isBackgroundLoadingComplete = false
   sessionRatedJokeIds.removeAll()
   ```
  </action>
  <verify>
Build the app:
- `xcodebuild -project MrFunnyJokes/MrFunnyJokes.xcodeproj -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`
- Verify no build errors
  </verify>
  <done>
- Background loading properties added to JokeViewModel
- triggerBackgroundLoadIfNeeded() method triggers on first scroll
- loadFullCatalogInBackground() silently loads full catalog
- refresh() cancels background loading and resets state
- App builds successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify filteredJokes to show only unrated jokes sorted by popularity</name>
  <files>MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift</files>
  <action>
Update the filteredJokes computed property to:
1. Filter out rated jokes (except those rated this session)
2. Sort by popularity score (descending)

Replace the existing `filteredJokes` computed property with:

```swift
var filteredJokes: [Joke] {
    // Step 1: Apply category filter if selected
    let categoryFiltered: [Joke]
    if let category = selectedCategory {
        categoryFiltered = jokes.filter { $0.category == category }
    } else {
        categoryFiltered = jokes
    }

    // Step 2: Filter to unrated only
    // Exception: Keep jokes rated THIS session visible until refresh
    // Per CONTEXT.md: "stays visible for current session, removed on next refresh"
    let unratedJokes = categoryFiltered.filter { joke in
        // If no rating, include it
        guard let _ = joke.userRating else { return true }

        // If rated this session, keep it visible
        let key = joke.firestoreId ?? joke.id.uuidString
        return sessionRatedJokeIds.contains(key)
    }

    // Step 3: Sort by popularity score (descending) per CONTEXT.md
    // "Unrated jokes ordered by popularity score (trending/popular first)"
    return unratedJokes.sorted { ($0.popularityScore ?? 0) > ($1.popularityScore ?? 0) }
}
```

Also update the `rateJoke(_:rating:)` method to track session-rated jokes:
After the line `let clampedRating = min(max(rating, 1), 5)`, add:
```swift
// Track this joke as rated during current session
// It will remain visible in feed until next refresh
let key = joke.firestoreId ?? joke.id.uuidString
sessionRatedJokeIds.insert(key)
```

Note: The existing `ratedJokes`, `hilariousJokes`, `funnyJokes`, etc. computed properties for the Me tab should NOT be modified - they already correctly show all rated jokes.
  </action>
  <verify>
Build the app:
- `xcodebuild -project MrFunnyJokes/MrFunnyJokes.xcodeproj -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`
- Verify no build errors
  </verify>
  <done>
- filteredJokes filters out rated jokes (except session-rated)
- filteredJokes sorts by popularityScore descending
- rateJoke tracks session-rated joke IDs
- App builds successfully
  </done>
</task>

<task type="auto">
  <name>Task 3: Add pull-to-refresh and error retry to JokeFeedView</name>
  <files>MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift</files>
  <action>
Add pull-to-refresh and wire up the retry button:

1. Add a state variable for tracking load errors:
   ```swift
   @State private var loadMoreFailed = false
   ```

2. Add `.refreshable` modifier to the ScrollView (before `.onChange`):
   ```swift
   .refreshable {
       // Full reset per CONTEXT.md
       await viewModel.refresh()
   }
   ```

3. Update the LoadingMoreView/retry section. Replace the existing loading and load-more sections with:
   ```swift
   // Loading more indicator (skeleton cards at bottom)
   if viewModel.isLoadingMore {
       LoadingMoreView()
           .transition(.opacity)
   }

   // Retry button (when load failed and not currently loading)
   if loadMoreFailed && !viewModel.isLoadingMore && !feedJokes.isEmpty {
       RetryLoadButton {
           loadMoreFailed = false
           viewModel.loadMore()
       }
   }

   // End of feed message (when no more jokes and not showing retry)
   if !viewModel.hasMoreJokes && !feedJokes.isEmpty && !loadMoreFailed {
       EndOfFeedView()
   }
   ```

4. The error state needs to be set when loading fails. Since JokeViewModel doesn't currently expose load errors, we'll use a simple approach: Add an onChange observer that detects when loading stops but hasMoreJokes is still true and jokes didn't increase.

   Actually, simpler approach: For now, the retry button is available if the user notices loading stopped. The background loading is silent per CONTEXT.md, so we won't surface errors prominently. Keep the loadMoreFailed state for future use but don't wire it to ViewModel state yet.

   Remove the loadMoreFailed state variable - it's not needed for MVP. The existing behavior (skeleton while loading, end-of-feed when done) is sufficient. Users can always pull-to-refresh to retry.

5. Final approach - just add refreshable and keep existing loading/end-of-feed behavior:
   - Add `.refreshable` modifier
   - Remove the LoadMoreButton conditional (already done in Plan 01)
   - Keep LoadingMoreView and EndOfFeedView as-is
  </action>
  <verify>
Build the app:
- `xcodebuild -project MrFunnyJokes/MrFunnyJokes.xcodeproj -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`
- Verify no build errors
- Check that .refreshable modifier is present on ScrollView
  </verify>
  <done>
- ScrollView has .refreshable modifier calling viewModel.refresh()
- Pull-to-refresh triggers full reset
- App builds successfully
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Infinite scroll with unrated-only feed filtering and background catalog loading:
1. Feed automatically loads more jokes when scrolling near bottom
2. Feed shows only unrated jokes, sorted by popularity
3. Rated jokes stay visible for current session, disappear on refresh
4. Background loading starts on first scroll (not app launch)
5. Pull-to-refresh resets everything
  </what-built>
  <how-to-verify>
1. Launch the app in Simulator or device
2. Go to the main joke feed (Jokes tab)
3. **Test infinite scroll:**
   - Scroll down through the jokes
   - Verify skeleton cards appear at bottom while loading
   - Verify no "Load More Jokes" button appears
   - Verify new jokes load automatically as you approach the end
4. **Test unrated-only filtering:**
   - Rate a joke (tap to open, use the rating stars)
   - Verify the joke is still visible (session tracking)
   - Pull down to refresh the feed
   - Verify the rated joke is no longer in the feed
   - Go to Me tab and verify the rated joke appears there
5. **Test popularity sorting:**
   - After refresh, check if jokes appear to be sorted by engagement (this may be subtle if all scores are similar)
6. **Test pull-to-refresh:**
   - Pull down on the feed
   - Verify refresh indicator appears
   - Verify feed reloads from the beginning
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Build succeeds without errors
2. Scrolling triggers automatic loading (no Load More button)
3. Feed shows only unrated jokes
4. Rated jokes appear in Me tab
5. Pull-to-refresh works and resets feed
6. Session-rated jokes stay visible until refresh
</verification>

<success_criteria>
- User scrolling feed reaches next page automatically at threshold (no tap required)
- "Load More" button no longer appears in feed UI
- Full joke catalog available for sorting after background load completes
- When returning to feed tab, unrated jokes appear before already-rated jokes
- Rated jokes are accessible via the Me tab
</success_criteria>

<output>
After completion, create `.planning/phases/08-feed-content-loading/08-02-SUMMARY.md`
</output>
