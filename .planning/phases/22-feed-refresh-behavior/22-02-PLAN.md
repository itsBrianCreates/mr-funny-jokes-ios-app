---
phase: 22-feed-refresh-behavior
plan: 02
type: execute
wave: 1
depends_on: ["22-01"]
files_modified:
  - "MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift"
  - "MrFunnyJokes/MrFunnyJokes/Views/JokeCardView.swift"
  - "MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift"
  - "MrFunnyJokes/MrFunnyJokes/Views/SearchView.swift"
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After rating a joke, it stays in its current position in the feed until pull-to-refresh or app restart"
    - "After pull-to-refresh, session-rated jokes move to the bottom of the feed"
    - "After app restart, previously-rated jokes appear at bottom via persisted ratings"
    - "Opening a joke detail sheet and then pulling to refresh demotes that joke below unseen jokes"
    - "After pull-to-refresh, unseen jokes appear at the top of the feed and previously seen jokes move down"
    - "Within each freshness tier, jokes are sorted by popularityScore (not randomly shuffled)"
  artifacts:
    - path: "MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift"
      provides: "Impression-tiered filteredJokes with sessionRatedJokeIds and viewed-joke tracking"
      contains: "sessionRatedJokeIds"
    - path: "MrFunnyJokes/MrFunnyJokes/Views/JokeCardView.swift"
      provides: "onView callback triggered when detail sheet opens"
      contains: "onView"
    - path: "MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift"
      provides: "onView wired to viewModel.markJokeViewed"
      contains: "markJokeViewed"
    - path: "MrFunnyJokes/MrFunnyJokes/Views/SearchView.swift"
      provides: "onView no-op closure to satisfy new JokeCardView parameter"
      contains: "onView"
  key_links:
    - from: "filteredJokes"
      to: "storage.getImpressionIdsFast()"
      via: "Freshness tiering: unseen > seen-unrated > rated"
      pattern: "impressionIds|getImpressionIdsFast"
    - from: "filteredJokes"
      to: "sessionRatedJokeIds"
      via: "Session-rated jokes stay in their current tier until refresh"
      pattern: "sessionRatedJokeIds\\.contains"
    - from: "rateJoke()"
      to: "sessionRatedJokeIds"
      via: "Insert joke ID on rating"
      pattern: "sessionRatedJokeIds\\.insert"
    - from: "refresh()"
      to: "sessionRatedJokeIds"
      via: "Clear set on pull-to-refresh"
      pattern: "sessionRatedJokeIds\\.removeAll"
    - from: "JokeCardView.showingSheet"
      to: "onView callback"
      via: "Button action triggers onView when sheet opens"
      pattern: "onView"
    - from: "JokeFeedView ForEach"
      to: "viewModel.markJokeViewed"
      via: "onView closure passed to JokeCardView"
      pattern: "markJokeViewed"
---

<objective>
Close 3 UAT gaps in feed refresh behavior: (1) rated jokes jump to bottom immediately instead of waiting for refresh, (2) viewed jokes (detail sheet opened) do not demote on refresh, (3) feed feels stale because filteredJokes sorts by popularityScore and ignores impression-based freshness tiering.

Purpose: The user reported that rating a joke causes it to disappear from its position (making it hard to share), opening a joke detail and refreshing does not demote it, and the same jokes always appear at the top regardless of how many times the user has seen them. All three gaps trace to filteredJokes ignoring impression data and immediately reacting to rating mutations.

Output: Updated JokeViewModel.swift with impression-tiered filteredJokes, sessionRatedJokeIds for deferred reordering, and viewed-joke tracking via JokeCardView onView callback.
</objective>

<execution_context>
@/Users/brianvanaski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brianvanaski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-feed-refresh-behavior/22-01-SUMMARY.md
@.planning/phases/22-feed-refresh-behavior/22-UAT.md
@MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift
@MrFunnyJokes/MrFunnyJokes/Views/JokeCardView.swift
@MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift
@MrFunnyJokes/MrFunnyJokes/Views/SearchView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite filteredJokes with impression-based tiering and session-deferred reordering</name>
  <files>MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift</files>
  <action>
This task addresses all 3 gaps by rewriting filteredJokes to use impression-based freshness tiering instead of pure popularityScore sorting, and adding sessionRatedJokeIds to defer rating reorder.

**1. Add sessionRatedJokeIds property**

Near the other private properties (around line 46, near `cancellables`), add:

```swift
/// Jokes rated during this session — kept in their current freshness tier
/// so they don't jump to the bottom immediately. Cleared on pull-to-refresh.
private var sessionRatedJokeIds: Set<String> = []
```

**2. Add markJokeViewed() method**

After the existing `markJokeImpression(_ joke:)` method (around line 306), add a new method for tracking detail-sheet opens. This uses the SAME impression system (`storage.markImpression`) because opening the detail sheet means the user has definitely "seen" the joke:

```swift
/// Marks a joke as explicitly viewed (detail sheet opened)
/// Uses the same impression tracking as scroll-viewport marking
func markJokeViewed(_ joke: Joke) {
    storage.markImpression(firestoreId: joke.firestoreId)
    invalidateSortCache()
}
```

Note: This deliberately reuses `markImpression` rather than a separate tracking system. The impression system already exists, is already used by `sortJokesForFreshFeed`, and "viewed in detail sheet" is a superset of "scrolled past in viewport." The distinction between "scrolled past" and "opened detail" does not need separate storage — both mean "seen."

**3. Rewrite filteredJokes computed property (lines 53-83)**

Replace the entire `filteredJokes` computed property with impression-based tiering. The key change: instead of sorting ALL unrated jokes by popularityScore (which defeats freshness), tier them by impression state, then sort within each tier by popularityScore.

```swift
var filteredJokes: [Joke] {
    // Step 1: Apply category filter if selected
    let categoryFiltered: [Joke]
    if let category = selectedCategory {
        categoryFiltered = jokes.filter { $0.category == category }
    } else {
        categoryFiltered = jokes
    }

    // Step 2: Tier by freshness using impression data
    // Unseen jokes first, then seen-but-unrated, then rated
    // Session-rated jokes stay in their pre-rating tier (unseen or seen-unrated)
    let impressionIds = cachedImpressionIds ?? storage.getImpressionIdsFast()
    let ratedIds = cachedRatedIds ?? storage.getRatedJokeIdsFast()

    var unseen: [Joke] = []
    var seenUnrated: [Joke] = []
    var rated: [Joke] = []

    for joke in categoryFiltered {
        let key = joke.firestoreId ?? joke.id.uuidString
        let isSessionRated = sessionRatedJokeIds.contains(key)

        // Session-rated jokes: treat as if they were NOT rated for tiering
        // They stay in their current position until pull-to-refresh
        let effectivelyRated = joke.userRating != nil && !isSessionRated
        let hasImpression = impressionIds.contains(key)
        let persistedRated = ratedIds.contains(key) && !isSessionRated

        if effectivelyRated || persistedRated {
            rated.append(joke)
        } else if !hasImpression {
            unseen.append(joke)
        } else {
            seenUnrated.append(joke)
        }
    }

    // Step 3: Sort within each tier by popularity (descending)
    // PopularityScore as tiebreaker preserves quality ordering within tiers
    let sortedUnseen = unseen.sorted { $0.popularityScore > $1.popularityScore }
    let sortedSeenUnrated = seenUnrated.sorted { $0.popularityScore > $1.popularityScore }
    let sortedRated = rated.sorted { $0.popularityScore > $1.popularityScore }

    // Step 4: Combine tiers — unseen first, seen-unrated middle, rated at bottom
    let combined = sortedUnseen + sortedSeenUnrated + sortedRated

    // MARK: - Seasonal Content Ranking
    // Step 5: Apply seasonal demotion for Christmas jokes outside Nov 1 - Dec 31
    if !SeasonalHelper.isChristmasSeason() {
        let nonChristmas = combined.filter { !$0.isChristmasJoke }
        let christmas = combined.filter { $0.isChristmasJoke }
        return nonChristmas + christmas
    } else {
        return combined
    }
}
```

Key design decisions in this rewrite:
- Uses `popularityScore` as tiebreaker within tiers (NOT shuffled — shuffling in `sortJokesForFreshFeed` is for initial load randomness; `filteredJokes` is a computed property that re-evaluates on every access, so shuffling would cause unstable sort order and scroll jumps)
- `sessionRatedJokeIds` prevents rated jokes from jumping tiers until refresh
- Uses `cachedImpressionIds` / `cachedRatedIds` (same caching pattern already used by `sortJokesForFreshFeed`) to avoid repeated disk reads on every computed property evaluation
- `persistedRated` check uses `ratedIds` from storage (not just `joke.userRating`) to catch jokes rated in previous sessions whose `userRating` was rehydrated

**4. Update rateJoke() to track session-rated jokes**

In `rateJoke(_ joke: Joke, rating: Int)` (currently around line 807):

When rating is removed (rating == 0), after `storage.removeRating(...)` and before the `if let index` block, add:
```swift
let sessionKey = joke.firestoreId ?? joke.id.uuidString
sessionRatedJokeIds.remove(sessionKey)
```

When a non-zero rating is applied (the `else` branch), after the existing `storage.saveRating(...)` call and before the `if let index` / `else` blocks, add:
```swift
let sessionKey = joke.firestoreId ?? joke.id.uuidString
sessionRatedJokeIds.insert(sessionKey)
```

**5. Clear sessionRatedJokeIds in refresh()**

In `refresh()` (currently around line 565), after `isRefreshing = true`, add:
```swift
// Clear session tracking so rated/viewed jokes reorder on refresh
sessionRatedJokeIds.removeAll()
```

**6. Do NOT modify sortJokesForFreshFeed()**

Leave `sortJokesForFreshFeed()` exactly as-is. It is used for initial load ordering (with shuffling for variety) and is correct for that purpose. The fix is in `filteredJokes` which was previously destroying its ordering.

**7. Do NOT modify CharacterDetailViewModel**

It does not have this freshness tiering concern — it only shows jokes for a single character and does not have unrated/rated separation.
  </action>
  <verify>
Build the project:
```bash
cd /Users/brianvanaski/conductor/workspaces/mr-funny-jokes-ios-app/tyler && xcodebuild -project MrFunnyJokes/MrFunnyJokes.xcodeproj -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5
```

Code review checks:
1. `sessionRatedJokeIds` exists as `private var sessionRatedJokeIds: Set<String> = []`
2. `filteredJokes` tiers by unseen > seenUnrated > rated (not pure popularityScore)
3. `filteredJokes` uses `sessionRatedJokeIds.contains()` to keep session-rated jokes in pre-rating tier
4. `filteredJokes` uses `popularityScore` as tiebreaker within tiers (not shuffled)
5. `rateJoke()` inserts into `sessionRatedJokeIds` on rating, removes on unrating
6. `refresh()` calls `sessionRatedJokeIds.removeAll()`
7. `markJokeViewed()` method exists and calls `storage.markImpression()`
8. `sortJokesForFreshFeed()` is unchanged
9. Seasonal demotion (Step 5) is preserved
10. Build succeeds with no errors
  </verify>
  <done>
- filteredJokes uses 3-tier impression-based ordering: unseen > seen-unrated > rated
- popularityScore used as tiebreaker within each tier (stable sort, no scroll jumps)
- sessionRatedJokeIds defers rating reorder until pull-to-refresh or app restart
- markJokeViewed() method added for detail-sheet-open tracking
- refresh() clears sessionRatedJokeIds
- sortJokesForFreshFeed() unchanged (still used for initial load shuffling)
- Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire onView callback from JokeCardView through JokeFeedView to ViewModel</name>
  <files>MrFunnyJokes/MrFunnyJokes/Views/JokeCardView.swift, MrFunnyJokes/MrFunnyJokes/Views/JokeFeedView.swift, MrFunnyJokes/MrFunnyJokes/Views/SearchView.swift</files>
  <action>
This task wires the detail-sheet-open event from JokeCardView to JokeViewModel.markJokeViewed() so that opening a joke's detail sheet marks it as "seen" for freshness tiering.

**1. Add onView callback to JokeCardView**

In `JokeCardView.swift`, add a new callback property after the existing `onSave` property (line 9):

```swift
let onView: () -> Void
```

The full property list should be:
```swift
let joke: Joke
let isCopied: Bool
let onShare: () -> Void
let onCopy: () -> Void
let onRate: (Int) -> Void
let onSave: () -> Void
let onView: () -> Void
```

**2. Call onView when detail sheet opens**

In the Button action (line 43-45), add `onView()` right after `showingSheet = true`:

```swift
Button {
    HapticManager.shared.mediumImpact()
    showingSheet = true
    onView()
} label: {
```

This fires when the user taps the card to open the detail sheet. It does NOT fire on scroll-viewport appearance (that is handled separately by `markJokeImpression` via `.onAppear` in JokeFeedView).

**3. Update JokeCardView Preview to include onView**

Update all 4 `JokeCardView` instances in the `#Preview` block (starting around line 121) to include `onView: {}`. For each instance, add `onView: {}` after `onSave: {}`:

```swift
JokeCardView(
    joke: ...,
    isCopied: ...,
    onShare: {},
    onCopy: {},
    onRate: { _ in },
    onSave: {},
    onView: {}
)
```

**4. Wire onView in JokeFeedView**

In `JokeFeedView.swift`, inside the `ForEach(feedJokes)` block (lines 105-120), add the `onView` parameter to the `JokeCardView` initializer:

```swift
JokeCardView(
    joke: joke,
    isCopied: viewModel.copiedJokeId == joke.id,
    onShare: { viewModel.shareJoke(joke) },
    onCopy: { viewModel.copyJoke(joke) },
    onRate: { rating in viewModel.rateJoke(joke, rating: rating) },
    onSave: { viewModel.saveJoke(joke) },
    onView: { viewModel.markJokeViewed(joke) }
)
```

**5. Update SearchView.swift with no-op onView**

In `SearchView.swift`, the `JokeCardView` initializer (around line 132-139) also needs the `onView` parameter. Add `onView: {}` (no-op closure) since search results don't participate in feed freshness:

```swift
JokeCardView(
    joke: joke,
    isCopied: viewModel.copiedJokeId == joke.id,
    onShare: { viewModel.shareJoke(joke) },
    onCopy: { viewModel.copyJoke(joke) },
    onRate: { rating in viewModel.rateJoke(joke, rating: rating) },
    onSave: { viewModel.saveJoke(joke) },
    onView: {}
)
```

**6. Do NOT add onView to JokeOfTheDayView**

The Joke of the Day card in JokeFeedView (lines 67-79) uses `JokeOfTheDayView`, NOT `JokeCardView`. It already calls `markJokeImpression` via `.onAppear`. No changes needed there.

**7. CharacterDetailView uses CharacterJokeCardView (not JokeCardView)**

No changes needed to CharacterDetailView — it uses a different component (`CharacterJokeCardView`), not `JokeCardView`.
  </action>
  <verify>
Build the project:
```bash
cd /Users/brianvanaski/conductor/workspaces/mr-funny-jokes-ios-app/tyler && xcodebuild -project MrFunnyJokes/MrFunnyJokes.xcodeproj -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5
```

Code review checks:
1. `JokeCardView` has `let onView: () -> Void` property
2. Button action calls `onView()` when sheet opens
3. Preview instances include `onView: {}`
4. JokeFeedView passes `onView: { viewModel.markJokeViewed(joke) }`
5. SearchView passes `onView: {}` (no-op)
6. No other JokeCardView call sites exist outside of these files
7. Build succeeds with no errors
  </verify>
  <done>
- JokeCardView has onView callback that fires when detail sheet opens
- JokeFeedView wires onView to viewModel.markJokeViewed(joke)
- SearchView updated with onView: {} no-op closure
- All JokeCardView call sites compile with onView parameter
- Opening a joke detail sheet now marks it as "seen" via impression tracking
- On next pull-to-refresh, viewed jokes will demote below unseen jokes
- Build succeeds
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild build` completes without errors
2. Gap 1 closed: `filteredJokes` uses `sessionRatedJokeIds.contains()` to keep session-rated jokes in their pre-rating tier; `refresh()` clears `sessionRatedJokeIds`
3. Gap 2 closed: `JokeCardView` fires `onView()` on detail sheet open; JokeFeedView wires it to `viewModel.markJokeViewed()`; `markJokeViewed()` calls `storage.markImpression()`; `filteredJokes` uses impression data for tiering
4. Gap 3 closed: `filteredJokes` tiers by unseen > seen-unrated > rated with popularityScore as tiebreaker within each tier (not pure popularityScore sorting)
5. No regressions: category filtering (Step 1), seasonal demotion (Step 5), infinite scroll, and sortJokesForFreshFeed (initial load) all unchanged
6. Stable sort: `filteredJokes` uses deterministic popularityScore ordering within tiers (NOT shuffled), preventing scroll position jumps on re-evaluation
</verification>

<success_criteria>
- Rating a joke does NOT cause it to jump to the bottom of the feed during the current session
- Pull-to-refresh clears sessionRatedJokeIds, causing rated jokes to reorder to the bottom
- Opening a joke detail sheet marks it as "seen"; on next refresh, it demotes below unseen jokes
- After pull-to-refresh, unseen jokes appear at the top, seen-unrated in the middle, rated at the bottom
- Within each freshness tier, jokes are ordered by popularityScore (highest first)
- App restart starts with empty sessionRatedJokeIds; previously-rated jokes appear at bottom via persisted data
- No regressions in category filtering, seasonal demotion, or infinite scroll
</success_criteria>

<output>
After completion, create `.planning/phases/22-feed-refresh-behavior/22-02-SUMMARY.md`
</output>
