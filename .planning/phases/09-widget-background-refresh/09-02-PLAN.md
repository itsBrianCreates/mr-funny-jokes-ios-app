---
phase: 09-widget-background-refresh
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - MrFunnyJokes/JokeOfTheDayWidget/JokeOfTheDayProvider.swift
  - MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift
autonomous: false

must_haves:
  truths:
    - "Widget checks if JOTD is stale (>24 hours) before displaying"
    - "Widget fetches directly from Firestore REST API when data is stale"
    - "Widget uses fallback cache when network fails and data is stale"
    - "Widget refreshes at midnight ET (not device timezone)"
    - "Main app populates fallback jokes cache when fetching jokes"
    - "All 6 widgets show fresh JOTD after overnight period without app launch"
  artifacts:
    - path: "MrFunnyJokes/JokeOfTheDayWidget/JokeOfTheDayProvider.swift"
      provides: "Enhanced timeline provider with stale detection and direct fetch"
      contains: "resolveJokeForDisplay"
    - path: "MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift"
      provides: "Fallback cache population"
      contains: "saveFallbackJokes"
  key_links:
    - from: "JokeOfTheDayProvider.swift"
      to: "WidgetDataFetcher"
      via: "direct fetch when stale"
      pattern: "WidgetDataFetcher.fetchJokeOfTheDay"
    - from: "JokeOfTheDayProvider.swift"
      to: "SharedStorageService"
      via: "fallback cache read"
      pattern: "getRandomFallbackJoke"
    - from: "JokeViewModel.swift"
      to: "SharedStorageService"
      via: "fallback cache write"
      pattern: "saveFallbackJokes"
---

<objective>
Wire up the widget background refresh system: enhance JokeOfTheDayProvider with stale detection and direct fetch fallback, and ensure the main app populates the fallback jokes cache.

Purpose: Complete the widget background refresh feature so widgets display fresh content without app launch, with graceful degradation when offline.
Output: Enhanced JokeOfTheDayProvider.swift with background fetch logic, JokeViewModel.swift wired to populate fallback cache
</objective>

<execution_context>
@/Users/brianvanaski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brianvanaski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-widget-background-refresh/09-RESEARCH.md
@.planning/phases/09-widget-background-refresh/09-01-SUMMARY.md
@MrFunnyJokes/JokeOfTheDayWidget/JokeOfTheDayProvider.swift
@MrFunnyJokes/JokeOfTheDayWidget/WidgetDataFetcher.swift
@MrFunnyJokes/Shared/SharedStorageService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance JokeOfTheDayProvider with Stale Detection and Direct Fetch</name>
  <files>MrFunnyJokes/JokeOfTheDayWidget/JokeOfTheDayProvider.swift</files>
  <action>
Rewrite JokeOfTheDayProvider.swift to implement background refresh with stale detection:

1. Keep existing `placeholder(in:)` method unchanged

2. Update `getSnapshot(in:completion:)`:
   - Load joke from SharedStorageService
   - Fall back to .placeholder if nil
   - No async work needed for snapshot

3. Rewrite `getTimeline(in:completion:)` to use async/await Task:
```swift
func getTimeline(in context: Context, completion: @escaping (Timeline<JokeOfTheDayEntry>) -> Void) {
    Task {
        let joke = await resolveJokeForDisplay()
        let entry = JokeOfTheDayEntry(date: Date(), joke: joke)

        // Schedule next refresh at midnight ET
        let nextRefresh = nextMidnightET()
        let timeline = Timeline(entries: [entry], policy: .after(nextRefresh))
        completion(timeline)
    }
}
```

4. Add private `resolveJokeForDisplay() async -> SharedJokeOfTheDay` method:
   - Step 1: Check for fresh data from main app via SharedStorageService.loadJokeOfTheDay()
     - If exists AND not stale (< 24 hours old), return it
   - Step 2: Data is stale or missing - try direct fetch via WidgetDataFetcher.fetchJokeOfTheDay()
     - If successful, save to SharedStorageService and return
   - Step 3: Network failed - use cached fallback via SharedStorageService.getRandomFallbackJoke()
     - If cache has jokes, return random one
   - Step 4: No cache (fresh install) - return SharedJokeOfTheDay.placeholder

5. Add private `isStale(_ date: Date) -> Bool` method:
   - Return true if Date().timeIntervalSince(date) > 86400 (24 hours)

6. Add private `nextMidnightET() -> Date` method:
   - Create Calendar with ET timezone: `TimeZone(identifier: "America/New_York")!`
   - Add 1 day to current date
   - Return startOfDay for tomorrow in ET
   - This ensures widgets refresh at midnight ET regardless of device timezone

Key: Use ET timezone for BOTH stale detection AND next refresh calculation for consistency with JOTD cycle.
  </action>
  <verify>
Build succeeds: `xcodebuild -workspace MrFunnyJokes.xcworkspace -scheme JokeOfTheDayWidgetExtension -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`
Implementation exists: `grep -E "(resolveJokeForDisplay|isStale|nextMidnightET|WidgetDataFetcher)" MrFunnyJokes/JokeOfTheDayWidget/JokeOfTheDayProvider.swift`
  </verify>
  <done>JokeOfTheDayProvider has stale detection, direct fetch fallback, ET timezone refresh, and graceful degradation to cached fallback</done>
</task>

<task type="auto">
  <name>Task 2: Wire Main App to Populate Fallback Cache</name>
  <files>MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift</files>
  <action>
Find the JokeViewModel (or equivalent ViewModel that fetches jokes from Firestore) and add fallback cache population.

1. Locate where jokes are fetched successfully from Firestore (look for `jokes` array being populated)

2. After jokes are fetched/loaded, add fallback cache population:
```swift
// Populate widget fallback cache with sample jokes
populateFallbackCache(from: jokes)
```

3. Add private helper method:
```swift
private func populateFallbackCache(from jokes: [Joke]) {
    // Convert to SharedJokeOfTheDay format
    let fallbackJokes = jokes.prefix(20).compactMap { joke -> SharedJokeOfTheDay? in
        // Split text into setup/punchline if needed
        let (setup, punchline) = splitJokeText(joke.text)
        return SharedJokeOfTheDay(
            id: joke.id ?? UUID().uuidString,
            setup: setup,
            punchline: punchline,
            category: joke.type,
            firestoreId: joke.id,
            character: joke.character,
            lastUpdated: Date()
        )
    }

    SharedStorageService.shared.saveFallbackJokes(Array(fallbackJokes))
}

private func splitJokeText(_ text: String) -> (setup: String, punchline: String) {
    // Split on common delimiters: newlines, dash, question mark, exclamation
    let delimiters = ["\n\n", "\n", " - "]
    for delimiter in delimiters {
        if let range = text.range(of: delimiter) {
            let setup = String(text[..<range.lowerBound])
            let punchline = String(text[range.upperBound...]).trimmingCharacters(in: .whitespaces)
            if !punchline.isEmpty {
                return (setup, punchline)
            }
        }
    }
    // Try splitting on "? " for Q&A style
    if let range = text.range(of: "? ") {
        let setup = String(text[..<range.upperBound]).trimmingCharacters(in: .whitespaces)
        let punchline = String(text[range.upperBound...]).trimmingCharacters(in: .whitespaces)
        if !punchline.isEmpty {
            return (setup, punchline)
        }
    }
    // No delimiter found - entire text is setup
    return (text, "")
}
```

4. Call `populateFallbackCache` after initial fetch and after any successful refresh/load

Note: Check the existing Joke model for property names (id, text, type, character) and adjust mapping accordingly.
  </action>
  <verify>
Build succeeds: `xcodebuild -workspace MrFunnyJokes.xcworkspace -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`
Cache population exists: `grep -r "saveFallbackJokes\|populateFallbackCache" MrFunnyJokes/MrFunnyJokes/`
  </verify>
  <done>Main app populates fallback jokes cache with 20 jokes when jokes are loaded from Firestore</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete widget background refresh system:
- WidgetDataFetcher: Direct Firestore REST API fetch (Plan 01)
- SharedStorageService: Fallback jokes cache (Plan 01)
- JokeOfTheDayProvider: Stale detection + direct fetch + fallback cascade (Plan 02)
- JokeViewModel: Fallback cache population from main app (Plan 02)
  </what-built>
  <how-to-verify>
**Test 1: Build verification**
1. Build and run main app on Simulator
2. Confirm app launches without crashes
3. Navigate to joke feed and load some jokes
4. Verify no errors in console

**Test 2: Widget functionality (Simulator)**
1. Add all widget sizes to home screen: small, medium, large
2. Add lock screen widgets: circular, rectangular, inline
3. All 6 should display a joke (may be placeholder initially)
4. Open main app, browse jokes, close app
5. Widgets should update with actual joke content

**Test 3: Background refresh (requires physical device)**
Note: Full background refresh testing requires leaving device overnight without opening app.
For now, verify the code compiles and widgets work when app is opened.

**Test 4: Firestore REST API (check console)**
1. If widgets show placeholder, check Xcode console for 403 errors
2. 403 = Firestore security rules need updating for public read
3. 200 = REST API working correctly

Expected: Widgets display jokes, no crashes, builds succeed.
  </how-to-verify>
  <resume-signal>Type "approved" to complete phase, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Widget extension builds without errors
2. Main app builds without errors
3. JokeOfTheDayProvider contains:
   - `resolveJokeForDisplay()` async method
   - `isStale()` method checking 24-hour threshold
   - `nextMidnightET()` method with America/New_York timezone
   - `WidgetDataFetcher.fetchJokeOfTheDay()` call
   - `getRandomFallbackJoke()` fallback

4. JokeViewModel (or equivalent) contains:
   - `saveFallbackJokes()` call
   - Conversion from Joke to SharedJokeOfTheDay

5. All 6 widget sizes render correctly in simulator/device
</verification>

<success_criteria>
- JokeOfTheDayProvider enhanced with stale detection (>24 hours)
- JokeOfTheDayProvider fetches directly via WidgetDataFetcher when stale
- JokeOfTheDayProvider falls back to cached joke when network fails
- JokeOfTheDayProvider schedules refresh at midnight ET (not device timezone)
- Main app populates fallback jokes cache when jokes are loaded
- All 6 widgets display jokes correctly
- User confirms widgets work after manual testing
</success_criteria>

<output>
After completion, create `.planning/phases/09-widget-background-refresh/09-02-SUMMARY.md`
</output>
