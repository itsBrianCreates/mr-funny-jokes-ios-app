---
phase: 17-save-system-rating-decoupling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - MrFunnyJokes/MrFunnyJokes/Models/Joke.swift
  - MrFunnyJokes/MrFunnyJokes/Services/LocalStorageService.swift
  - MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift
  - MrFunnyJokes/MrFunnyJokes/ViewModels/CharacterDetailViewModel.swift
autonomous: true

must_haves:
  truths:
    - "Saving a joke persists the saved state across app restarts via UserDefaults"
    - "All previously rated jokes are automatically migrated to saved jokes on first launch"
    - "Save state is applied to every joke after every load path (cache, API, refresh, infinite scroll)"
    - "Save changes in CharacterDetailViewModel are synchronized to JokeViewModel via notification"
  artifacts:
    - path: "MrFunnyJokes/MrFunnyJokes/Services/LocalStorageService.swift"
      provides: "saveJoke, unsaveJoke, isJokeSaved, getSavedTimestamp, migrateRatedToSavedIfNeeded methods"
      contains: "savedJokeIds"
    - path: "MrFunnyJokes/MrFunnyJokes/Models/Joke.swift"
      provides: "isSaved property on Joke struct"
      contains: "var isSaved"
    - path: "MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift"
      provides: "saveJoke/unsaveJoke methods, savedJokes computed property, save notification handling, migration trigger"
      contains: "jokeSaveDidChange"
    - path: "MrFunnyJokes/MrFunnyJokes/ViewModels/CharacterDetailViewModel.swift"
      provides: "saveJoke/unsaveJoke methods, save notification posting"
      contains: "jokeSaveDidChange"
  key_links:
    - from: "LocalStorageService.saveJoke()"
      to: "UserDefaults"
      via: "savedJokeIds and savedJokeTimestamps keys"
      pattern: "savedJokeIds"
    - from: "JokeViewModel.loadInitialContentAsync()"
      to: "LocalStorageService.migrateRatedToSavedIfNeeded()"
      via: "PHASE 0 migration call before memory cache preload"
      pattern: "migrateRatedToSavedIfNeeded"
    - from: "CharacterDetailViewModel"
      to: "JokeViewModel"
      via: ".jokeSaveDidChange notification"
      pattern: "jokeSaveDidChange"
---

<objective>
Add save persistence layer, Joke model extension, ViewModel save/unsave logic, cross-ViewModel notification sync, and rated-to-saved migration.

Purpose: Build the complete data and logic layer for saving jokes independently of rating, so that Plan 02 can wire up the UI without needing any storage or ViewModel changes.
Output: LocalStorageService save methods, Joke.isSaved property, ViewModel save/unsave/notification/migration, savedJokes computed property.
</objective>

<execution_context>
@/Users/brianvanaski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brianvanaski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-save-system-rating-decoupling/17-RESEARCH.md
@MrFunnyJokes/MrFunnyJokes/Services/LocalStorageService.swift
@MrFunnyJokes/MrFunnyJokes/Models/Joke.swift
@MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift
@MrFunnyJokes/MrFunnyJokes/ViewModels/CharacterDetailViewModel.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add save persistence to LocalStorageService, isSaved to Joke model, and rated-to-saved migration</name>
  <files>
    MrFunnyJokes/MrFunnyJokes/Services/LocalStorageService.swift
    MrFunnyJokes/MrFunnyJokes/Models/Joke.swift
  </files>
  <action>
**LocalStorageService.swift** -- Add a new `// MARK: - Save System (v1.1.0)` section (place it after the existing Rating Migration section). Add these keys and methods following the exact pattern of the rating persistence code:

1. **Keys:** `private let savedJokesKey = "savedJokeIds"` and `private let savedTimestampsKey = "savedJokeTimestamps"` (parallel to `ratingsKey` and `ratingTimestampsKey`).

2. **saveJoke(firestoreId: String):** Inside `queue.sync`, load saved IDs (Set<String>), insert the firestoreId, save back. Also load saved timestamps dictionary, set `timestamps[firestoreId] = Date().timeIntervalSince1970`, save back.

3. **unsaveJoke(firestoreId: String):** Inside `queue.sync`, remove firestoreId from saved IDs set, remove from timestamps dictionary, save both back.

4. **isJokeSaved(firestoreId: String) -> Bool:** Inside `queue.sync`, return whether the saved IDs set contains firestoreId.

5. **getSavedTimestamp(for firestoreId: String) -> TimeInterval?:** Inside `queue.sync`, return the timestamp for the given firestoreId from the saved timestamps dictionary.

6. **Private helpers:** `loadSavedIdsSync() -> Set<String>` (load array from UserDefaults, convert to Set), `saveSavedIdsSync(_ ids: Set<String>)` (convert to Array, save to UserDefaults), `loadSavedTimestampsSync() -> [String: TimeInterval]` (load dict from UserDefaults), `saveSavedTimestampsSync(_ timestamps: [String: TimeInterval])` (save dict to UserDefaults). These follow the exact pattern of `loadRatingsSync`/`saveRatingsSync`.

7. **Add migration section** `// MARK: - Save Migration (v1.1.0)` with `migrateRatedToSavedIfNeeded()`:
   - Guard on `userDefaults.bool(forKey: "hasMigratedRatedToSaved")` returning early if already done.
   - Inside `queue.sync`: load all ratings via `loadRatingsSync()` and rating timestamps via `loadRatingTimestampsSync()`. Load saved IDs and saved timestamps. For each `(jokeId, _)` in ratings, insert `jokeId` into saved IDs, and set saved timestamp to the rating timestamp (if it exists) or `Date().timeIntervalSince1970` as fallback.
   - Save both saved IDs and saved timestamps back.
   - After the `queue.sync` block, set `userDefaults.set(true, forKey: "hasMigratedRatedToSaved")`.

8. **Memory cache:** Also add `savedJokeIds` to the memory cache preload if one exists. Check `preloadMemoryCacheAsync()` -- if it preloads ratings into memory, do the same for saved IDs. If there is no memory cache for ratings, skip this step.

**Joke.swift** -- Add `var isSaved: Bool` property to the Joke struct:
1. Add `var isSaved: Bool = false` after the existing `var userRating: Int?` property.
2. Add `isSaved` to the `CodingKeys` enum.
3. In the `init(from decoder:)` method, add `isSaved = try container.decodeIfPresent(Bool.self, forKey: .isSaved) ?? false` (backward compatible).
4. In the manual `init(...)` if one exists, add `isSaved: Bool = false` parameter.
5. Make sure `Equatable` conformance includes `isSaved` (if Equatable is synthesized, adding the property is sufficient; if there's a custom `==` implementation, add `isSaved` to it).
  </action>
  <verify>Build the project with `xcodebuild build -project MrFunnyJokes/MrFunnyJokes.xcodeproj -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 17 Pro' -quiet 2>&1 | tail -5`. Zero errors.</verify>
  <done>LocalStorageService has save/unsave/isJokeSaved/getSavedTimestamp/migrateRatedToSavedIfNeeded methods. Joke struct has isSaved: Bool property. Project compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Wire save logic into both ViewModels with notification sync, migration trigger, and save state application</name>
  <files>
    MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift
    MrFunnyJokes/MrFunnyJokes/ViewModels/CharacterDetailViewModel.swift
  </files>
  <action>
**CharacterDetailViewModel.swift** -- Add save notification name and save methods:

1. In the existing `extension Notification.Name` block (line ~5-7), add: `static let jokeSaveDidChange = Notification.Name("jokeSaveDidChange")`.

2. Add a `// MARK: - Saving` section. Add `saveJoke(_ joke: Joke)` method:
   - Determine firestoreId: `let key = joke.firestoreId ?? joke.id.uuidString`
   - Check current state: `let currentlySaved = storage.isJokeSaved(firestoreId: key)`
   - Toggle: if currently saved, call `storage.unsaveJoke(firestoreId: key)`, else call `storage.saveJoke(firestoreId: key)`.
   - Update local state: find the joke in `self.jokes` array by id, set `jokes[index].isSaved = !currentlySaved`.
   - Post notification using the EXACT same pattern as `rateJoke` notification posting:
     ```swift
     let jokeData = try? JSONEncoder().encode(updatedJoke)
     NotificationCenter.default.post(
         name: .jokeSaveDidChange,
         object: nil,
         userInfo: [
             "jokeId": joke.id,
             "firestoreId": key,
             "isSaved": !currentlySaved,
             "jokeData": jokeData as Any
         ]
     )
     ```

3. **Apply save state in loadJokes():** Everywhere `storage.getRating(for:firestoreId:)` is called to set `mutableJoke.userRating`, add on the next line: `mutableJoke.isSaved = storage.isJokeSaved(firestoreId: joke.firestoreId ?? joke.id.uuidString)`. There are two locations: `loadJokes()` and `loadMoreJokes()`.

**JokeViewModel.swift** -- Add save logic, migration trigger, notification handling, and save state application:

1. **Migration trigger:** In `loadInitialContentAsync()`, find the existing PHASE 0 where `storage.migrateRatingsToBinaryIfNeeded()` is called. Add `storage.migrateRatedToSavedIfNeeded()` immediately after it (same phase, before memory cache preload).

2. **Add `// MARK: - Saving` section** with:
   - `func saveJoke(_ joke: Joke)`: Same pattern as CharacterDetailViewModel's version -- toggle save state via storage, update local `jokes` array, post `.jokeSaveDidChange` notification. Use `withAnimation` when updating the local array to animate the state change (per CLAUDE.md animation patterns).
   - `func unsaveJoke(_ joke: Joke)`: Calls `saveJoke` (since saveJoke toggles). OR implement as a dedicated unsave that calls `storage.unsaveJoke()`, updates local array with `withAnimation`, and posts notification. The latter is cleaner for the MeView swipe-to-delete use case.

3. **Add `savedJokes` computed property** (place near `ratedJokes`/`hilariousJokes`/`horribleJokes`):
   ```swift
   var savedJokes: [Joke] {
       let saved = jokes.filter { $0.isSaved }
       return saved.sorted { joke1, joke2 in
           let t1 = storage.getSavedTimestamp(for: joke1.firestoreId ?? joke1.id.uuidString) ?? 0
           let t2 = storage.getSavedTimestamp(for: joke2.firestoreId ?? joke2.id.uuidString) ?? 0
           return t1 > t2
       }
   }
   ```

4. **Notification subscription:** In `init()`, add a subscription to `.jokeSaveDidChange` using the exact same Combine pattern as the `.jokeRatingDidChange` subscription:
   ```swift
   NotificationCenter.default.publisher(for: .jokeSaveDidChange)
       .receive(on: DispatchQueue.main)
       .sink { [weak self] notification in
           self?.handleSaveNotification(notification)
       }
       .store(in: &cancellables)
   ```

5. **`handleSaveNotification(_ notification: Notification)`:** Mirror `handleRatingNotification`. Extract `jokeId` (UUID), `isSaved` (Bool), and optionally `jokeData` from userInfo. Find the joke in `jokes` array by id, update its `isSaved` property. If not found and `jokeData` exists, decode the joke and append it. Use `withAnimation` for the array mutation.

6. **Apply save state in ALL load paths:** Search for every line that calls `storage.getRating(for:firestoreId:)` and add a parallel `storage.isJokeSaved()` call on the next line. The research identified these locations:
   - `loadInitialContentAsync()` (cached jokes, line ~330)
   - `fetchInitialAPIContent()` (line ~475)
   - `fetchInitialAPIContentBackground()` (line ~532)
   - `refresh()` (line ~620)
   - `loadFullCatalogInBackground()` (line ~692)
   - `performLoadMore()` (line ~769)
   - `jokeOfTheDay` computed property (line ~146, JOTD fallback)

   For each, after the line `mutableJoke.userRating = storage.getRating(for: joke.id, firestoreId: joke.firestoreId)`, add:
   `mutableJoke.isSaved = storage.isJokeSaved(firestoreId: joke.firestoreId ?? joke.id.uuidString)`

   **Do not miss any.** The research lists all locations. Grep for `storage.getRating` to double-check.
  </action>
  <verify>Build the project with `xcodebuild build -project MrFunnyJokes/MrFunnyJokes.xcodeproj -scheme MrFunnyJokes -destination 'platform=iOS Simulator,name=iPhone 17 Pro' -quiet 2>&1 | tail -5`. Zero errors. Then grep to confirm: `grep -c 'isJokeSaved' MrFunnyJokes/MrFunnyJokes/ViewModels/JokeViewModel.swift` should return 8+ (one per load path plus the savedJokes computed property).</verify>
  <done>Both ViewModels have save/unsave methods with notification sync. Migration runs at PHASE 0 in loadInitialContentAsync. Save state applied in every load path. savedJokes computed property returns saved jokes sorted newest-first. Project compiles with zero errors.</done>
</task>

</tasks>

<verification>
1. `grep -rn 'isJokeSaved' MrFunnyJokes/MrFunnyJokes/` -- should show hits in LocalStorageService, JokeViewModel (8+), CharacterDetailViewModel (2+)
2. `grep -rn 'jokeSaveDidChange' MrFunnyJokes/MrFunnyJokes/` -- should show hits in CharacterDetailViewModel (definition + post) and JokeViewModel (subscribe + handle)
3. `grep -rn 'migrateRatedToSavedIfNeeded' MrFunnyJokes/MrFunnyJokes/` -- should show hits in LocalStorageService (definition) and JokeViewModel (call site)
4. `grep -rn 'var isSaved' MrFunnyJokes/MrFunnyJokes/Models/Joke.swift` -- should show the property
5. Build succeeds with zero errors
</verification>

<success_criteria>
- LocalStorageService has complete save CRUD (save, unsave, isSaved, getSavedTimestamp) plus migration
- Joke model has isSaved property with backward-compatible Codable support
- Both ViewModels can save/unsave jokes and sync via notification
- Migration converts all rated jokes to saved jokes at PHASE 0
- Save state applied in every joke loading code path (8+ locations in JokeViewModel, 2 in CharacterDetailViewModel)
- Project builds with zero compile errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-save-system-rating-decoupling/17-01-SUMMARY.md`
</output>
